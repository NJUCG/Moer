/**
 * @file PathIntegrator-new.cpp
 * @author Chenxi Zhou
 * @brief Path Integrator with new implementations
 * @version 0.1
 * @date 2022-09-21
 * 
 * @copyright NJUMeta (c) 2022 
 * www.njumeta.com
 */

#include "PathIntegrator-new.h"

PathIntegratorNew::PathIntegratorNew(std::shared_ptr<Camera> _camera,
                                     std::unique_ptr<Film> _film,
                                     std::unique_ptr<TileGenerator> _tileGenerator,
                                     std::shared_ptr<Sampler> _sampler,
                                     int _spp,
                                     int _renderThreadNum) : 
    AbstractPathIntegrator(_camera, 
                           std::move(_film), 
                           std::move(_tileGenerator), 
                           _sampler, _spp, 
                           _renderThreadNum)
{

}

Spectrum PathIntegratorNew::Li(const Ray &initialRay, 
                               std::shared_ptr<Scene> scene) 
{
    Spectrum L{.0};
    Spectrum throughput{1.0};
    Ray ray = initialRay;
    int nBounces = 0;
    auto itsOpt = scene->intersect(ray);
    PathIntegratorLocalRecord evalLightRecord = PathIntegratorUtils::evalEmittance(scene, itsOpt, ray);

    while (true) {

        //* All rays generated by bsdf/phase sampling which might hold radiance
        //* will be counted at the end of the loop
        //* except the ray generated by camera which is considered here
        if (nBounces == 0) {
            if (!evalLightRecord.f.isBlack()) {
                L += throughput * evalLightRecord.f;
            }    
        }

        //* No intersection
        if (!itsOpt.has_value())
            break;
        
        auto its = itsOpt.value();

        nBounces++;
        double pSurvive = PathIntegratorUtils::russianRoulette(nBounces,nPathLengthLimit,pRussianRoulette);
        if (randFloat() > pSurvive)
            break;
        throughput /= pSurvive;

        //* ----- Direct Illumination -----
        for (int i = 0; i < nDirectLightSamples; ++i) {
            PathIntegratorLocalRecord sampleLightRecord = PathIntegratorUtils::sampleDirectLighting(scene, its, ray,sampler);
            PathIntegratorLocalRecord evalScatterRecord = PathIntegratorUtils::evalScatter(scene, its, ray, sampleLightRecord.wi);

            if (!sampleLightRecord.f.isBlack()) {
                //* Multiple importance sampling
                double misw = MISWeight(sampleLightRecord.pdf, evalScatterRecord.pdf);
                if (sampleLightRecord.isDelta) {
                    misw = 1.0;
                }
                L += throughput * sampleLightRecord.f * evalScatterRecord.f 
                     / sampleLightRecord.pdf * misw
                     / nDirectLightSamples;
            }
        }

        //*----- BSDF Sampling -----
        PathIntegratorLocalRecord sampleScatterRecord = PathIntegratorUtils::sampleScatter(scene, its, ray,sampler);
        if (!sampleScatterRecord.f.isBlack()) {
            throughput *= sampleScatterRecord.f / sampleScatterRecord.pdf;
        } else {
            break;
        }

        //* Test whether the bsdf sampling ray hit the emitter
        const double eps = 1e-4;
        ray = Ray{its.position + sampleScatterRecord.wi * eps, sampleScatterRecord.wi};
        itsOpt = scene->intersect(ray);

        evalLightRecord = PathIntegratorUtils::evalEmittance(scene, itsOpt, ray);
        if (!evalLightRecord.f.isBlack()) {
            //* The continuous ray hit the emitter
            //* Multiple importance sampling

            double misw = MISWeight(sampleScatterRecord.pdf, evalLightRecord.pdf);
            if (sampleScatterRecord.isDelta) {
                misw = 1.0;
            }

            L += throughput * evalLightRecord.f * misw;
        }
        
    }

    return L;

}
