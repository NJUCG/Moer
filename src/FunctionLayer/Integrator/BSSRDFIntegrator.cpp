#include "FunctionLayer/Material/BSSRDF/BSSRDF.h"

#include "BSSRDFIntegrator.h"


Spectrum BSSRDFIntegrator::Li(const Ray &initialRay, std::shared_ptr<Scene> scene) {

    Spectrum L{.0};
    Spectrum throughput{1.0};
    Ray ray = initialRay;
    int nBounces = 0;
    auto itsOpt = scene->intersect(ray);
    PathIntegratorLocalRecord evalLightRecord = evalEmittance(scene, itsOpt, ray);

    while (true) {

        //* All rays generated by bsdf/phase sampling which might hold radiance
        //* will be counted at the end of the loop
        //* except the ray generated by camera which is considered here
        if (nBounces == 0) {
            if (!evalLightRecord.f.isBlack()) {
                L += throughput * evalLightRecord.f;
            }
        }

        //* No intersection
        if (!itsOpt.has_value())
            break;

        Intersection its = itsOpt.value();
        nBounces++;
        double pSurvive = russianRoulette(throughput, nBounces);
        if (randFloat() > pSurvive)
            break;
        throughput /= pSurvive;

        //* ----- Direct Illumination -----
        for (int i = 0; i < nDirectLightSamples; ++i) {
            PathIntegratorLocalRecord sampleLightRecord = sampleDirectLighting(scene, its, ray);
            PathIntegratorLocalRecord evalScatterRecord = evalScatter(its, ray, sampleLightRecord.wi);
            // return Spectrum(RGB3(sampleLightRecord.wi.x,sampleLightRecord.wi.y,sampleLightRecord.wi.z));
            if (!sampleLightRecord.f.isBlack()) {
                //* Multiple importance sampling
                double misw = MISWeight(sampleLightRecord.pdf, evalScatterRecord.pdf);
                if (sampleLightRecord.isDelta) {
                    misw = 1.0;
                }
                L += throughput * sampleLightRecord.f * evalScatterRecord.f / sampleLightRecord.pdf * misw / nDirectLightSamples;
            }

            auto sampleScatterRecord = sampleScatter(scene, its, ray);

            //* Test whether the bsdf sampling ray hit the emitter
            const double eps = 1e-4;
            auto sampleRay = Ray{its.position + sampleScatterRecord.wi * eps, sampleScatterRecord.wi};
            auto temp_itsOpt = scene->intersect(sampleRay);
            evalLightRecord = evalEmittance(scene, temp_itsOpt, sampleRay);
            if (!evalLightRecord.f.isBlack()) {
                //* The continuous ray hit the emitter
                //* Multiple importance sampling
                double misw = MISWeight(sampleScatterRecord.pdf, evalLightRecord.pdf);
                if (sampleScatterRecord.isDelta) {
                    misw = 1.0;
                    break;
                }
                L += throughput * evalLightRecord.f * misw * sampleScatterRecord.f / sampleScatterRecord.pdf;
            }
        }
        //            //*----- BSDF Sampling -----
        SubSurfaceLocalRecord sampleSubSurfaceRecord = sampleSubsurface(scene, its, ray, throughput);
        L += sampleSubSurfaceRecord.L;
        if (!sampleSubSurfaceRecord.f.isBlack()) {
            throughput *= sampleSubSurfaceRecord.f / sampleSubSurfaceRecord.pdf;
        } else {
            break;
        }
        ray = Ray{sampleSubSurfaceRecord.point + sampleSubSurfaceRecord.wi * 1e-4, sampleSubSurfaceRecord.wi};
        itsOpt = scene->intersect(ray);
    }
    return L;
}

BSSRDFIntegrator::BSSRDFIntegrator(std::shared_ptr<Camera> _camera,
                                   std::unique_ptr<Film> _film,
                                   std::unique_ptr<TileGenerator> _tileGenerator,
                                   std::shared_ptr<Sampler> _sampler,
                                   int _spp,
                                   int _renderThreadNum)
    : PathIntegratorNew(_camera, std::move(_film), std::move(_tileGenerator), _sampler, _spp, _renderThreadNum) {
}

PathIntegratorLocalRecord
BSSRDFIntegrator::sampleScatter(std::shared_ptr<Scene> scene, const Intersection &its, const Ray &ray) {
    if (its.material != nullptr) {
        Vec3d wo = its.toLocal(-ray.direction);
        std::shared_ptr<BxDF> bxdf = its.material->getBxDF(its);
        Vec3d n = its.geometryNormal;
        BxDFSampleResult bsdfSample = bxdf->sample(wo, sampler->sample2D(), false);
        double pdf = bsdfSample.pdf;
        Vec3d dirScatter = its.toWorld(bsdfSample.directionIn);
        double wiDotN = fm::abs(dot(dirScatter, n));
        return {dirScatter, bsdfSample.s * wiDotN, pdf, BxDF::MatchFlags(bsdfSample.bxdfSampleType, BXDF_SPECULAR)};
    } else {
        // todo: sample phase function
        return {};
    }
}


SubSurfaceLocalRecord
BSSRDFIntegrator::sampleSubsurface(std::shared_ptr<Scene> scene, const Intersection &its, const Ray &ray,
                                   const Spectrum &originThr) {
    if (its.material != nullptr) {
        Vec3d wo = its.toLocal(-ray.direction);
        std::shared_ptr<BxDF> bxdf = its.material->getBxDF(its);
        Vec3d n = its.geometryNormal;
        BxDFSampleResult bsdfSample = bxdf->sample(wo, sampler->sample2D(), false);
        Vec3d dirScatter = its.toWorld(bsdfSample.directionIn);
        double wiDotN = fm::abs(dot(dirScatter, n));
        Spectrum throughput = bsdfSample.s * wiDotN / bsdfSample.pdf;

        auto bssrdf = its.material->getBSSRDF(its);
        Spectrum directL(0);
        if (bsdfSample.bxdfSampleType & BXDF_TRANSMISSION && bssrdf ) {

            Intersection pi;

            Spectrum bssrdfPdf;
            Spectrum s = bssrdf->sampleS(*scene, sampler->sample1D(), sampler->sample2D(), &pi, &bssrdfPdf, wo);
            if (s.isBlack() || bssrdfPdf.isBlack())
                return {Vec3d(), Spectrum(0), 0, false,0,Point3d (0)};
            throughput *= s / bssrdfPdf;

            //handle direct lighting
            //* ----- Direct Illumination -----
            //Shadow ray's origin not used.The interface design for "mis" seems a bit impractical.
            // It currently requires passing in the information about light separately.
            // Perhaps in the future, it might be a good idea to incorporate the direction of the light into the "intersection".
            Ray shadowRay(pi.position - wo,wo,1e-4);
            for (int i = 0; i < nDirectLightSamples; ++i) {
                PathIntegratorLocalRecord sampleLightRecord = sampleDirectLighting(scene, pi, shadowRay);
                PathIntegratorLocalRecord evalScatterRecord = evalScatter(pi, shadowRay, sampleLightRecord.wi);
                if (!sampleLightRecord.f.isBlack()) {
                    //* Multiple importance sampling
                    double misw = MISWeight(sampleLightRecord.pdf, evalScatterRecord.pdf);
                    if (sampleLightRecord.isDelta) {
                        misw = 1.0;
                    }
                    directL += originThr * throughput * sampleLightRecord.f * evalScatterRecord.f / sampleLightRecord.pdf * misw / nDirectLightSamples;
                }

                auto sampleScatterRecord = sampleScatter(scene, pi, shadowRay);
                //* Test whether the bsdf sampling ray hit the emitter
                const double eps = 1e-4;
                auto sampleRay = Ray{pi.position + sampleScatterRecord.wi * eps, sampleScatterRecord.wi};
                auto itsOpt = scene->intersect(sampleRay);
                auto evalLightRecord = evalEmittance(scene, itsOpt, sampleRay);
                if (!evalLightRecord.f.isBlack()) {
                    //* The continuous ray hit the emitter
                    //* Multiple importance sampling
                    double misw = MISWeight(sampleScatterRecord.pdf, evalLightRecord.pdf);
                    if (sampleScatterRecord.isDelta) {
                        misw = 1.0;
                    }
                    directL += originThr * throughput * evalLightRecord.f * misw * sampleScatterRecord.f / sampleScatterRecord.pdf;
                }
            }
            std::shared_ptr<BxDF> newBxdf = pi.material->getBxDF(pi);
            BxDFSampleResult newSample = newBxdf->sample(pi.toLocal(wo), sampler->sample2D(), false);

            if (newSample.s.isBlack() || newSample.pdf == 0) {
                return {Vec3d(), Spectrum(0), 0, false,0,Point3d (0)};
            }

            dirScatter = pi.toWorld(newSample.directionIn);


            throughput *= newSample.s * std::abs(dot(dirScatter, pi.geometryNormal)) / newSample.pdf;
            return {dirScatter, throughput, 1, BxDF::MatchFlags(newSample.bxdfSampleType, BXDF_SPECULAR), directL, pi.position};
        } else
            return {dirScatter, bsdfSample.s * wiDotN, bsdfSample.pdf, BxDF::MatchFlags(bsdfSample.bxdfSampleType, BXDF_SPECULAR), Spectrum(0), its.position};
    } else {
        // todo: sample phase function
        return {};
    }
}
